---
schema_version: 1
id: d5g389g
status: open
blocked-by: [d5g34k8, d5g34y0, d5g35r0, d5g366g, d5g36br, d5g36gr, d5g36mg, d5g36rg, d5g36wg, d5g3710, d5g37b0, d5g37yg, d5g3830, d5g3900, d5g393g, d5g37p0, d5g39b0, d5g3tgg]
created: 2026-01-08T22:48:06Z
type: task
priority: 1
---
# Integration: Complete Exec Command Pipeline

## Background & Context

This task integrates all the individual components into the complete exec
command flow. It's the "glue" that connects:

1. Platform validation
2. Config loading and CLI flag merging
3. Preset expansion
4. Path resolution pipeline
5. Specificity resolution
6. Command wrapper setup
7. bwrap argument generation
8. Sandbox execution

## Rationale

Individual components have been built and tested in isolation. This task
ensures they work together correctly, with proper error handling at each
step and correct data flow between components.

## Implementation Details

```go
// In cmd_exec.go
func ExecCmd(cfg *Config, env map[string]string) *Command {
    return &Command{
        Exec: func(ctx context.Context, stdin io.Reader, stdout, stderr io.Writer, args []string) error {
            // 1. Platform validation (d5g34k8)
            if err := validatePlatform(); err != nil {
                return err
            }
            
            // 2. Parse exec flags
            if err := flags.Parse(args); err != nil {
                return err
            }
            
            // 3. Apply CLI flags to config (d5g34y0)
            cfg = applyCliFlags(cfg, flags)
            
            // 4. Get command to run
            command := flags.Args()
            if len(command) == 0 {
                return ErrNoCommand
            }
            
            // 5. Create debug logger (d5g3710)
            debug := NewDebugLogger(flags.GetBool("debug"), stderr)
            
            // 6. Expand presets (d5g35r0)
            debug.Section("Preset Expansion")
            presetPaths, err := ExpandPresets(cfg.Filesystem.Presets, PresetContext{
                HomeDir:            homeDir,
                WorkDir:            cfg.EffectiveCwd,
                LoadedConfigPaths:  loadedConfigPaths,
            })
            if err != nil {
                return err
            }
            debug.LogPresets(presetPaths)
            
            // 7. Resolve all paths (d5g366g)
            debug.Section("Path Resolution")
            // IMPORTANT: preserve layer/source (preset/global/project/cli) for SPEC rule 4.
            // ResolvePaths should take per-layer path lists, not only the merged cfg.Filesystem.
            resolvedPaths, err := ResolvePaths(presetPaths, globalCfg.Filesystem, projectCfg.Filesystem, cliFilesystem, homeDir, cfg.EffectiveCwd)
            if err != nil {
                return err
            }
            debug.LogPaths(resolvedPaths)
            
            // 8. Apply specificity rules (d5g36br)
            debug.Section("Specificity Resolution")
            finalPaths := ResolveSpecificity(resolvedPaths)
            debug.LogFinalPaths(finalPaths)
            
            // 9. Set up command wrappers (d5g37b0)
            debug.Section("Command Wrappers")
            runtimeBase := fmt.Sprintf("/run/%s/agent-sandbox", randomString(8))
            sandboxWrapBinaryPath := filepath.Join(runtimeBase, "binaries", "wrap-binary")

            wrapperSetup, err := GenerateWrappers(cfg.Commands, binPaths, sandboxWrapBinaryPath)
            if err != nil {
                return err
            }
            defer wrapperSetup.Cleanup()
            debug.LogWrappers(wrapperSetup)
            
            // 10. Generate bwrap args (d5g36gr, d5g36mg, d5g37yg, d5g39b0)
            debug.Section("bwrap Arguments")
            bwrapArgs, err := BwrapArgs(finalPaths, cfg)
            if err != nil {
                return err
            }

            // Add self-mount, marker, wrapper mounts, docker masking, etc.
            bwrapArgs, err = AddWrapperMounts(bwrapArgs, wrapperSetup, selfBinary, runtimeBase)
            if err != nil {
                return err
            }
            debug.LogBwrapArgs(bwrapArgs)
            
            // 11. Dry run or execute (d5g36wg, d5g36rg)
            if dryRun, _ := flags.GetBool("dry-run"); dryRun {
                return printDryRun(stdout, bwrapArgs, command)
            }
            
            exitCode, err := ExecuteSandbox(ctx, bwrapArgs, command, env, stdin, stdout, stderr)
            if err != nil {
                return err
            }
            if exitCode != 0 {
                return &ExitError{Code: exitCode}
            }
            return nil
        },
    }
}
```

## Files to Modify
- cmd/agent-sandbox/cmd_exec.go - complete integration
- cmd/agent-sandbox/cmd_exec_test.go - E2E integration tests

## Key Invariants
- All components called in correct order
- Error from any step stops execution
- Debug output shows entire pipeline
- Wrapper cleanup happens even on error (defer)
- Exit code propagated from sandboxed process

## Acceptance Criteria

1. Full pipeline executes in correct order
2. Error at any step stops execution with clear message
3. Debug output shows all steps when --debug enabled
4. Dry run works end-to-end
5. Actual execution works end-to-end
6. Exit code from sandboxed process returned
7. Wrapper cleanup always happens (even on error)
8. E2E test: run real command in sandbox
9. E2E test: verify filesystem restrictions work
10. E2E test: verify command wrappers work
