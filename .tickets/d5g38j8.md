---
schema_version: 1
id: d5g38j8
status: closed
closed: 2026-01-09T06:18:14Z
blocked-by: [d5g389g, d5g37p0]
created: 2026-01-08T22:48:41Z
type: task
priority: 2
---
# E2E Tests: Command Wrapper Verification

## Background & Context

Command wrappers intercept specific binaries. E2E tests must verify that:
- Blocked commands actually fail
- Preset rules actually block dangerous operations
- Custom wrappers receive correct environment

## Rationale

Command wrappers are a "defense in depth" layer. While filesystem permissions
are the ultimate enforcement, wrappers prevent common mistakes and provide
clear feedback. We need to verify they work correctly.

## Implementation Details

**Important:** These tests need the compiled binary because command wrappers
invoke the sandbox runtime `wrap-binary` subcommand internally. Use `RunBinary()` from test 
helpers (see d5g39g8).

```go
func Test_Sandbox_Command_Wrappers(t *testing.T) {
    RequireBwrap(t)
    RequireGit(t)
    
    tests := []struct {
        name    string
        config  string
        command []string
        wantErr bool
        errMsg  string // Expected error message substring
    }{
        {
            name:    "blocked command fails",
            config:  `{"commands": {"cat": false}}`,
            command: []string{"cat", "/etc/passwd"},
            wantErr: true,
            errMsg:  "blocked",
        },
        {
            name:    "git checkout blocked by @git preset",
            config:  `{}`, // Default includes git: "@git"
            command: []string{"git", "checkout", "main"},
            wantErr: true,
            errMsg:  "git switch",
        },
        {
            name:    "git push --force blocked",
            config:  `{}`,
            command: []string{"git", "push", "--force"},
            wantErr: true,
            errMsg:  "force-with-lease",
        },
        {
            name:    "git status allowed",
            config:  `{}`,
            command: []string{"git", "status"},
            wantErr: false,
        },
        {
            name:    "raw command bypasses wrapper",
            config:  `{"commands": {"git": true}}`,
            command: []string{"git", "checkout", "main"}, // Would fail normally
            // Doesn't fail (wrapper disabled) - but may fail for other reasons
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            dir := TempGitRepo(t)
            writeConfig(t, dir, tt.config)
            
            args := append([]string{"-C", dir, "exec", "--"}, tt.command...)
            _, stderr, exit := RunBinary(t, args...)
            
            if tt.wantErr && exit == 0 {
                t.Error("expected error, got success")
            }
            if !tt.wantErr && exit != 0 {
                t.Errorf("expected success, got exit %d: %s", exit, stderr)
            }
            if tt.errMsg != "" && !strings.Contains(stderr, tt.errMsg) {
                t.Errorf("expected error containing %q, got: %s", tt.errMsg, stderr)
            }
        })
    }
}
```

**Git tests require:**
- A temporary git repository (git init)
- Maybe a branch to checkout (for checkout tests)
- Careful cleanup

## Files to Create
- cmd/agent-sandbox/e2e_wrapper_test.go - E2E wrapper tests

## Key Invariants
- Tests with real git binary
- Tests with real bwrap
- Error messages match SPEC alternatives
- Wrapper disable (true) actually works
- Tests clean up git repos

## Acceptance Criteria

1. Test verifies commands: false blocks command with clear message
2. Test verifies @git blocks checkout (mentions "git switch")
3. Test verifies @git blocks reset --hard
4. Test verifies @git blocks push --force
5. Test verifies @git allows safe operations (status, log, diff)
6. Test verifies commands: true disables wrapper
7. Tests skip gracefully if git/bwrap not available
8. All tests pass with current implementation
