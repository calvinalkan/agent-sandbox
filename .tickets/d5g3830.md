---
schema_version: 1
id: d5g3830
status: open
blocked-by: [d5g36rg]
created: 2026-01-08T22:47:40Z
type: task
priority: 1
---
# Signal Handling: Graceful Termination of Sandboxed Process

## Background & Context

Per SPEC.md Signal Handling section:
> When agent-sandbox receives an interrupt signal (SIGINT/SIGTERM):
> 1. Signal is forwarded to the sandboxed process
> 2. Waits up to 10 seconds for graceful termination
> 3. A second interrupt forces immediate exit
> 4. Exit code is 130

Current run.go has basic signal handling with context cancellation, but doesn't
explicitly forward signals to the child process.

## Rationale

Proper signal handling ensures:
- Ctrl+C gracefully stops the sandboxed process
- Long-running processes can clean up before exit
- Force-kill option prevents hanging
- Exit code 130 is the Unix convention for SIGINT

## Implementation Details

exec.CommandContext sends SIGKILL on context cancel, which is too aggressive.
We need explicit signal forwarding:

```go
func ExecuteSandbox(ctx context.Context, ...) (int, error) {
    cmd := exec.Command("bwrap", args...)
    // ... setup stdin/stdout/stderr ...
    
    if err := cmd.Start(); err != nil {
        return 1, err
    }
    
    // Handle context cancellation (from signal)
    done := make(chan error, 1)
    go func() {
        done <- cmd.Wait()
    }()
    
    select {
    case err := <-done:
        // Normal completion
        if err != nil {
            var exitErr *exec.ExitError
            if errors.As(err, &exitErr) {
                return exitErr.ExitCode(), nil
            }
            return 1, err
        }
        return 0, nil
        
    case <-ctx.Done():
        // First signal - send SIGTERM for graceful shutdown
        cmd.Process.Signal(syscall.SIGTERM)
        
        // Wait up to 10 seconds
        select {
        case err := <-done:
            if err != nil {
                var exitErr *exec.ExitError
                if errors.As(err, &exitErr) {
                    return 130, nil // Interrupted
                }
            }
            return 130, nil
            
        case <-time.After(10 * time.Second):
            // Timeout - force kill
            cmd.Process.Kill()
            <-done
            return 130, nil
        }
    }
}
```

Note: The Run() function already handles the second signal and 10-second timeout.
We need to coordinate so that:
1. First signal → context cancelled → SIGTERM to child
2. Second signal or timeout → SIGKILL to child

## Files to Modify
- cmd/agent-sandbox/bwrap.go - improve signal handling in ExecuteSandbox
- cmd/agent-sandbox/run.go - may need adjustment for coordination
- cmd/agent-sandbox/cmd_exec_test.go - test signal handling

## Key Invariants
- First signal → SIGTERM (graceful)
- Second signal or timeout → SIGKILL (force)
- Exit code 130 for interrupted processes
- Clean process group handling (no zombies)

## Acceptance Criteria

1. Ctrl+C sends SIGTERM to sandboxed process
2. Process has up to 10 seconds to exit gracefully
3. Second Ctrl+C forces immediate SIGKILL
4. Timeout forces SIGKILL after 10 seconds
5. Exit code is 130 for interrupted processes
6. No zombie processes left behind
7. Works with long-running processes (e.g., npm start)
8. Tests verify signal forwarding (may need subprocess helper)
