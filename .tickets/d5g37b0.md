---
schema_version: 1
id: d5g37b0
status: open
blocked-by: [d5g375g, d5g34q0]
created: 2026-01-08T22:46:04Z
type: task
priority: 1
---
# Command Wrappers: Wrapper Script Generation

## Background & Context

Per TECHNICAL_STEERING.md, command wrappers use generated scripts:

> **Wrapper scripts:**
> ```bash
> # deny-binary - single static script, uses \$0 for command name:
> #!/bin/bash
> echo "command '\$(basename \$0)' is blocked in this sandbox" >&2
> exit 1
>
> # For preset (@git):
> exec <sandboxWrapBinaryPath> wrap-binary --preset @git git "\$@"
>
> # For custom wrapper script:
> exec <sandboxWrapBinaryPath> wrap-binary --script "/path/to/user/script" npm "\$@"
> ```

Scripts are created in a temp directory before bwrap runs, then mounted into
the sandbox over the original binary locations.

## Rationale

Script generation is the mechanism that makes wrappers work:
1. **Blocking:** Mount deny-binary over all binary paths
2. **@preset:** Mount wrapper script that execs `wrap-binary --preset ...` (no `$PATH` lookup)
3. **Custom:** Mount wrapper script that execs `wrap-binary --script ...`, which sets `AGENT_SANDBOX_<CMD>` and execs the user script

The temp directory approach keeps things clean - scripts are created on the host,
mounted into sandbox, then cleaned up.

## Implementation Details

```go
// WrapperSetup contains the temp directory and mount info for wrappers
type WrapperSetup struct {
    TempDir  string              // Host temp directory
    Mounts   []WrapperMount      // Mounts to add to bwrap
    Cleanup  func()              // Call to remove temp dir
}

type WrapperMount struct {
    Source      string // Path on host (in temp dir)
    Destination string // Path in sandbox (original binary location)
}

// GenerateWrappers creates wrapper scripts for all configured commands
func GenerateWrappers(commands map[string]CommandRule, binPaths map[string][]BinaryPath, sandboxWrapBinaryPath string) (*WrapperSetup, error) {
    tempDir, err := os.MkdirTemp("", "agent-sandbox-wrappers-")
    if err != nil {
        return nil, err
    }
    
    setup := &WrapperSetup{
        TempDir: tempDir,
        Cleanup: func() { os.RemoveAll(tempDir) },
    }
    
    // Create deny-binary script (shared)
    denyScript := filepath.Join(tempDir, "deny-binary")
    if err := writeDenyScript(denyScript); err != nil {
        setup.Cleanup()
        return nil, err
    }
    
    for cmdName, config := range commands {
        paths, ok := binPaths[cmdName]
        if !ok || len(paths) == 0 {
            continue // Binary not found, skip
        }
        
        switch config.Kind {
        case CommandRuleBlock:
            // Block: mount deny-binary at all locations
            for _, p := range paths {
                setup.Mounts = append(setup.Mounts, WrapperMount{
                    Source:      denyScript,
                    Destination: p.Path,
                })
            }
            
        case CommandRuleRaw:
            // Raw: no wrapper (don't add any mounts)
            
        case CommandRulePreset:
            // Preset wrapper
            wrapperScript := filepath.Join(tempDir, "wrap-"+cmdName)
            if err := writePresetWrapper(wrapperScript, sandboxWrapBinaryPath, cmdName, config.Value); err != nil {
                setup.Cleanup()
                return nil, err
            }
            for _, p := range paths {
                setup.Mounts = append(setup.Mounts, WrapperMount{
                    Source:      wrapperScript,
                    Destination: p.Path,
                })
            }
            
        case CommandRuleScript:
            // Custom script path
            wrapperScript := filepath.Join(tempDir, "wrap-"+cmdName)
            if err := writeCustomWrapper(wrapperScript, sandboxWrapBinaryPath, cmdName, config.Value); err != nil {
                setup.Cleanup()
                return nil, err
            }
            for _, p := range paths {
                setup.Mounts = append(setup.Mounts, WrapperMount{
                    Source:      wrapperScript,
                    Destination: p.Path,
                })
            }
        default:
            setup.Cleanup()
            return nil, fmt.Errorf("invalid command rule for %q", cmdName)
        }
    }
    
    return setup, nil
}
```

**Wrapper script safety:** wrapper scripts should **not** call `agent-sandbox` via `$PATH`.
Use an absolute path (the mounted sandbox wrap-binary binary), e.g.:
```bash
exec <sandboxWrapBinaryPath> wrap-binary --preset @git git "$@"
```
This prevents PATH-injection via writable directories (like the workdir) inside the sandbox.

**Passing preset/custom selection to wrap-binary (arguments, not env vars):**
- Preset wrapper script passes `--preset @git`
- Custom wrapper script passes `--script /path/to/user/script`

This keeps `wrap-binary` runtime-independent: it does not need to load config files inside the sandbox.
The only required user-facing env var remains `AGENT_SANDBOX_<CMD>` (set by `wrap-binary` when exec'ing a custom user script).

## Files to Modify
- cmd/agent-sandbox/wrapper.go - add script generation
- cmd/agent-sandbox/wrapper_test.go - test script creation

## Key Invariants
- Temp directory cleaned up after bwrap exits
- deny-binary shared across all blocked commands
- Scripts are executable (chmod +x)
- All binary paths for a command get same wrapper
- "true" config means no wrapper (original binary used)

## Acceptance Criteria

1. Temp directory created with unique name
2. deny-binary script created and executable
3. Preset wrappers exec `<sandboxWrapBinaryPath> wrap-binary --preset @git <cmd> "$@"` (no $PATH lookup)
4. Custom wrappers exec `<sandboxWrapBinaryPath> wrap-binary --script <path> <cmd> "$@"`; `wrap-binary` sets `AGENT_SANDBOX_<CMD>` and execs the user script
5. "false" config mounts deny-binary at all locations
6. "true" config adds no mounts (raw command)
7. Cleanup function removes temp directory
8. Scripts are executable (mode 0755)
9. Tests verify script content and permissions
