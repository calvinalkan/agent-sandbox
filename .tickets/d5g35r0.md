---
schema_version: 1
id: d5g35r0
status: open
blocked-by: [d5g357r, d5g35ar, d5g35f8, d5g35k0, d5g34t8]
created: 2026-01-08T22:42:40Z
type: task
priority: 1
---
# Presets: Implement @all Preset and Preset Expansion Engine

## Background & Context

The @all preset combines all other presets and is the default. Per SPEC.md:

> @all: Everything: @base, @caches, @git, @lint/all
> **Default:** @all is always applied. Use !@preset to exclude.

The preset expansion engine handles:
1. Expanding preset names to their paths
2. Handling preset negation (!@preset syntax)
3. Combining multiple presets

## Rationale

The preset system allows users to opt-out of specific protections when needed:
```jsonc
{
  "filesystem": {
    "presets": ["!@lint/python"]  // @all is default, remove python lint protection
  }
}
```

The engine must:
1. Start with @all (always applied by default)
2. Process user's preset list (additions and removals)
3. Expand all presets to concrete paths
4. Merge all paths (duplicates handled by specificity later)

## Implementation Details

**Key insight:** Treat `filesystem.presets` as an **ordered list of toggles** applied
on top of the implicit `@all` default:
- `!@name` disables a preset
- `@name` (non-negated) re-enables a preset (useful after disabling `@lint/all`, or if a user disables `@all`)

```go
// ExpandPresets processes the preset configuration and returns merged paths
func ExpandPresets(presets []string, ctx PresetContext) (PresetPaths, error) {
    disabled := make(map[string]bool)       // preset -> disabled?
    roots := []string{"@all"}               // deterministic expansion order
    seenRoot := map[string]bool{"@all": true}
    
    for _, p := range presets {
        negated := strings.HasPrefix(p, "!")
        name := strings.TrimPrefix(p, "!")
        if _, exists := PresetRegistry[name]; !exists {
            return PresetPaths{}, fmt.Errorf("unknown preset: %s", name)
        }

        // Record explicit roots so users can do things like: ["!@all", "@base"]
        // or ["!@lint/all", "@lint/python"].
        if !negated {
            if !seenRoot[name] {
                seenRoot[name] = true
                roots = append(roots, name)
            }
        }

        // Toggle semantics (last mention wins).
        disabled[name] = negated
    }
    
    // Expand roots, respecting disabled presets.
    // Duplicates are fine; specificity handles path conflicts later.
    var result PresetPaths
    for _, name := range roots {
        paths, err := expandPresetRecursive(name, ctx, disabled)
        if err != nil {
            return PresetPaths{}, err
        }
        result.Ro = append(result.Ro, paths.Ro...)
        result.Rw = append(result.Rw, paths.Rw...)
        result.Exclude = append(result.Exclude, paths.Exclude...)
    }

    return result, nil
}

// expandPresetRecursive expands a preset, skipping disabled ones
func expandPresetRecursive(name string, ctx PresetContext, disabled map[string]bool) (PresetPaths, error) {
    if disabled[name] {
        return PresetPaths{}, nil // Skip disabled preset
    }
    
    preset := PresetRegistry[name]
    if preset == nil {
        return PresetPaths{}, fmt.Errorf("unknown preset: %s", name)
    }
    
    // For composite presets (@all, @lint/all), Resolve() internally
    // calls expandPresetRecursive for sub-presets, passing disabled map
    return preset.Resolve(ctx, disabled), nil
}
```

**Composite preset expansion with disabled check:**
```go
// @all.Resolve checks disabled before calling sub-presets
func resolveAll(ctx PresetContext, disabled map[string]bool) PresetPaths {
    var result PresetPaths
    for _, name := range []string{"@base", "@caches", "@git", "@lint/all"} {
        if disabled[name] {
            continue
        }
        paths := expandPresetRecursive(name, ctx, disabled)
        result.Ro = append(result.Ro, paths.Ro...)
        result.Rw = append(result.Rw, paths.Rw...)
        result.Exclude = append(result.Exclude, paths.Exclude...)
    }
    return result
}

// Similarly for @lint/all
func resolveLintAll(ctx PresetContext, disabled map[string]bool) PresetPaths {
    var result PresetPaths
    for _, name := range []string{"@lint/ts", "@lint/go", "@lint/python"} {
        if disabled[name] {
            continue
        }
        paths := PresetRegistry[name].Resolve(ctx, disabled)
        result.Ro = append(result.Ro, paths.Ro...)
        // ...
    }
    return result
}
```

This approach correctly handles:
- `!@lint/python` - disables just Python lint preset
- `!@lint/all` - disables all lint presets (ts, go, python)
- `!@caches` - disables cache directories
```

**@all Implementation:**
```go
// @all is a composite preset - calls other presets
func resolveAll(ctx PresetContext) PresetPaths {
    var result PresetPaths
    for _, name := range []string{"@base", "@caches", "@git", "@lint/all"} {
        paths := PresetRegistry[name].Resolve(ctx)
        result.Ro = append(result.Ro, paths.Ro...)
        // ... etc
    }
    return result
}
```

**Error Handling:**
- Unknown preset reference → error (per SPEC)
- Invalid negation (e.g., "!invalid") → error

## Files to Modify
- cmd/agent-sandbox/preset.go - implement @all and ExpandPresets function
- cmd/agent-sandbox/preset_test.go - test expansion and negation

## Key Invariants
- @all is ALWAYS the starting point (implicit default)
- Preset list supports toggling: `!@x` disables, `@x` re-enables (last mention wins)
- Unknown presets cause errors
- Composite presets (like @all) must expand sub-presets
- Duplicates in paths are OK (specificity handles them later)

## Acceptance Criteria

1. @all.Resolve() combines @base, @caches, @git, @lint/all
2. ExpandPresets() starts with @all implicitly
3. !@preset syntax removes preset from active set
4. !@lint/all removes all lint presets (@lint/ts, @lint/go, @lint/python)
5. Unknown preset in config returns descriptive error
6. Empty presets config still applies @all
7. Non-negated presets can re-enable after disable (e.g., ["!@lint/all", "@lint/python"])
8. Multiple negations work (e.g., ["!@lint/python", "!@lint/go"])
9. Tests cover: default expansion, negation, composite removal, re-enable, errors
