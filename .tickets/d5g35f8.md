---
schema_version: 1
id: d5g35f8
status: open
blocked-by: [d5g3538]
created: 2026-01-08T22:42:05Z
type: task
priority: 1
---
# Presets: Implement @git Preset with Worktree Detection

## Background & Context

The @git preset protects Git repository configuration and hooks. Per SPEC.md:

> @git: Git hooks and config protected (.git/hooks, .git/config), with automatic 
> worktree support

Git worktrees are a special case: the .git file in a worktree is a text file 
pointing to the main repository's .git directory. We must detect and handle this.

## Rationale

Git hooks are security-sensitive:
- Pre-commit hooks run before each commit
- Pre-push hooks run before push
- Post-checkout hooks run after checkout

An agent modifying these could:
- Exfiltrate secrets on push
- Bypass safety checks
- Execute arbitrary code on common git operations

The .git/config file controls remotes, which could be changed to malicious endpoints.

## Implementation Details

**Normal repo (.git is directory):**
```
.git/
├── hooks/     # protect (ro)
├── config     # protect (ro)
├── objects/
└── refs/
```

**Worktree (.git is file):**
```
# In worktree directory:
.git           # file containing "gitdir: /main/repo/.git/worktrees/myworktree"

# The gitdir points to:
/main/repo/.git/worktrees/myworktree/
├── HEAD
├── commondir  # file containing ".." (relative path to main .git)
├── hooks/     # may exist, protect (ro)
└── config     # worktree-specific config, protect (ro)

# The commondir resolves to main repo:
/main/repo/.git/
├── hooks/     # shared hooks, protect (ro)
├── config     # main config, protect (ro)
├── objects/   # shared
└── refs/      # shared
```

**Detection and resolution (from v1):**
```go
func resolveGitPaths(workDir string) (*GitPaths, error) {
    gitPath := filepath.Join(workDir, ".git")
    info, err := os.Lstat(gitPath)
    if err != nil {
        return nil, nil // No .git, not a git repo
    }
    
    result := &GitPaths{}
    
    if info.IsDir() {
        // Normal repo
        result.Hooks = filepath.Join(gitPath, "hooks")
        result.Config = filepath.Join(gitPath, "config")
        return result, nil
    }
    
    // Worktree: .git is a file
    content, err := os.ReadFile(gitPath)
    if err != nil {
        return nil, err
    }
    
    // Parse "gitdir: /path/to/.git/worktrees/name"
    gitdirLine := strings.TrimSpace(string(content))
    if !strings.HasPrefix(gitdirLine, "gitdir: ") {
        return nil, fmt.Errorf("invalid .git file format")
    }
    worktreeGitDir := strings.TrimPrefix(gitdirLine, "gitdir: ")
    
    // Protect worktree-specific hooks/config
    result.Hooks = filepath.Join(worktreeGitDir, "hooks")
    result.Config = filepath.Join(worktreeGitDir, "config")
    
    // Find commondir to get main repo's .git
    commondirPath := filepath.Join(worktreeGitDir, "commondir")
    if commondirContent, err := os.ReadFile(commondirPath); err == nil {
        commondir := strings.TrimSpace(string(commondirContent))
        mainGitDir := filepath.Join(worktreeGitDir, commondir)
        mainGitDir, _ = filepath.Abs(mainGitDir)
        
        // Also protect main repo's hooks/config
        result.MainHooks = filepath.Join(mainGitDir, "hooks")
        result.MainConfig = filepath.Join(mainGitDir, "config")
    }
    
    return result, nil
}

type GitPaths struct {
    Hooks      string // worktree or normal .git/hooks
    Config     string // worktree or normal .git/config
    MainHooks  string // main repo hooks (only for worktrees)
    MainConfig string // main repo config (only for worktrees)
}
```

**@git preset returns ro paths for all discovered hooks/config paths.**

## Files to Modify
- cmd/agent-sandbox/preset.go - implement @git Resolve function
- cmd/agent-sandbox/preset_test.go - test with regular repo and worktree scenarios

## Key Invariants
- Must protect hooks/config in BOTH worktree gitdir AND main repo (commondir)
- Handle repos with no .git gracefully (return empty paths)
- Keep scope limited to what SPEC requires (repo root / worktree handling)

## Acceptance Criteria

1. Normal repo: returns .git/hooks and .git/config as ro
2. Worktree: correctly parses `gitdir:` line from .git file
3. Worktree: correctly parses `commondir` to find main repo
4. Worktree: protects hooks/config in BOTH worktree gitdir AND main repo
5. Non-git directories return empty paths (no error)
6. Invalid .git file format returns error
7. Tests cover: normal repo, worktree, non-git directory
8. Integration test: create real git repo with `git init` in t.TempDir(), verify correct paths returned
9. Integration test: create worktree with `git worktree add`, verify BOTH main and worktree paths returned

**Note:** These tests verify the preset returns correct PATHS. Actual sandbox PROTECTION
tests (verifying files can't be modified) are in d5g3efr (E2E Git Protection Tests).
