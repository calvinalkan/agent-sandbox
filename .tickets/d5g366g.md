---
schema_version: 1
id: d5g366g
status: open
blocked-by: [d5g35wg, d5g361g]
created: 2026-01-08T22:43:38Z
type: task
priority: 1
---
# Path Resolution: Full Pipeline and Existence Checking

## Background & Context

This task integrates all path resolution components into a complete pipeline:
1. Home and relative path expansion (d5g35wg)
2. Glob pattern expansion (d5g361g)
3. Symlink resolution
4. Existence checking

Per SPEC.md error conditions:
> Path doesn't exist (non-glob) → Skip silently (may exist in other projects)
> Glob matches nothing → Skip silently (pattern may be valid for other projects)

## Rationale

The complete path resolution pipeline transforms user-friendly paths into
absolute, real filesystem paths that bwrap can mount. Non-existent paths are
filtered out rather than causing errors (global configs may reference paths
that only exist on some machines).

## Implementation Details

```go
// ResolvedPath represents a path ready for bwrap mounting
type ResolvedPath struct {
    Original string // Original pattern from config
    Resolved string // Absolute, symlink-resolved path
    Access   string // "ro", "rw", or "exclude"
    Source   string // "preset", "global", "project", "cli" (for specificity)
}

// IMPORTANT: preserve layer/source for SPEC rule 4 (CLI > project > global > preset).
// Collect paths per-layer before merging into a single Config so each ResolvedPath
// carries its true Source.

// ResolvePaths processes all paths from config/presets into mount-ready paths
func ResolvePaths(
    presetPaths PresetPaths,
    globalPaths FilesystemConfig,
    projectPaths FilesystemConfig,
    cliPaths FilesystemConfig,
    homeDir, workDir string,
) ([]ResolvedPath, error) {
    var result []ResolvedPath
    
    // Process each source in order (for specificity tie-breaking)
    // 1. Preset paths
    for _, p := range presetPaths.Ro {
        resolved, err := resolveOne(p, "ro", "preset", homeDir, workDir)
        if err != nil {
            return nil, err
        }
        result = append(result, resolved...)
    }
    // ... rw, exclude
    
    // 2. Global config paths
    // 3. Project config paths
    // 4. CLI paths
    
    return result, nil
}

func resolveOne(pattern, access, source, homeDir, workDir string) ([]ResolvedPath, error) {
    // 1. Expand ~ and relative paths
    expanded, err := ResolvePath(pattern, homeDir, workDir)
    if err != nil {
        return nil, err
    }
    
    // 2. Expand globs
    paths, err := ExpandGlob(expanded)
    if err != nil {
        return nil, err // Invalid glob is an error
    }
    
    // 3. For each path: check existence, resolve symlinks
    var result []ResolvedPath
    for _, p := range paths {
        info, err := os.Lstat(p)
        if errors.Is(err, os.ErrNotExist) {
            continue // Skip non-existent (per SPEC)
        }
        if err != nil {
            return nil, err // Other errors are real errors
        }
        
        // Resolve symlinks
        real, err := filepath.EvalSymlinks(p)
        if err != nil {
            return nil, err
        }
        
        result = append(result, ResolvedPath{
            Original: pattern,
            Resolved: real,
            Access:   access,
            Source:   source,
        })
    }
    
    return result, nil
}
```

## Files to Modify
- cmd/agent-sandbox/path.go - add full pipeline
- cmd/agent-sandbox/path_test.go - integration tests

## Key Invariants
- Non-existent paths are silently skipped (not errors)
- Permission errors ARE errors (vs non-existence)
- Symlinks are resolved to real paths
- Source tracking preserved for specificity
- Pipeline order: expand → glob → exist → symlink

## Acceptance Criteria

1. Complete pipeline transforms patterns to resolved paths
2. Non-existent paths filtered out (no error)
3. Permission errors surface as errors
4. Symlinks resolved via EvalSymlinks
5. Source tracking (preset/global/project/cli) preserved
6. Access level (ro/rw/exclude) preserved
7. Globs that match nothing produce no paths (no error)
8. Integration test with real filesystem structure
