---
schema_version: 1
id: d5g39b0
status: open
blocked-by: [d5g37b0, d5g37yg]
created: 2026-01-08T22:50:20Z
type: task
priority: 1
---
# Command Wrappers: Integrate Wrappers with bwrap Mounts

## Background & Context

Per TECHNICAL_STEERING.md, command wrappers work by mounting scripts over
the original binary locations. This task integrates the wrapper setup with
the bwrap argument generation.

Directory structure inside sandbox:
```
/run/<random>/agent-sandbox/binaries/
├── wrap-binary          # agent-sandbox binary
└── real/
    ├── git              # real git binary
    └── npm              # real npm binary

/usr/bin/git             # bind mount of wrapper script
/usr/bin/npm             # bind mount of wrapper script
```

## Rationale

The wrapper scripts need:
1. Access to real binaries at a known location
2. Access to agent-sandbox for wrap-binary command
3. Mounts over all original binary paths

This task ensures the bwrap args include all necessary mounts.

## Implementation Details

```go
func AddWrapperMounts(args []string, wrapperSetup *WrapperSetup, selfBinary string, runtimeBase string) ([]string, error) {
    if wrapperSetup == nil {
        return args, nil
    }
    
    // runtimeBase is chosen once per exec invocation (before wrapper script generation)
    // so wrapper scripts can exec an absolute path that is guaranteed to exist inside the sandbox.
    binDir := filepath.Join(runtimeBase, "binaries")
    realDir := filepath.Join(binDir, "real")
    
    // Mount agent-sandbox binary for wrap-binary command
    sandboxWrapBinaryPath := filepath.Join(binDir, "wrap-binary")
    args = append(args, "--ro-bind", selfBinary, sandboxWrapBinaryPath)
    
    // Mount real binaries
    for cmdName, paths := range wrapperSetup.RealBinaries {
        if len(paths) == 0 {
            continue
        }
        // Use the first resolved path as the canonical real binary
        realPath := paths[0].Resolved
        destPath := filepath.Join(realDir, cmdName)
        args = append(args, "--ro-bind", realPath, destPath)
    }
    
	    // Mount wrapper scripts over original locations
	    for _, mount := range wrapperSetup.Mounts {
	        // Mount read-only so sandboxed processes cannot tamper with wrapper behavior.
	        args = append(args, "--ro-bind", mount.Source, mount.Destination)
	    }
    
    return args, nil
}
```

**The wrap-binary convention:**
The wrap-binary command finds the real binary at:
```go
selfPath, _ := os.Executable()
selfDir := filepath.Dir(selfPath)
realBinary := filepath.Join(selfDir, "real", cmdName)
```

This convention must be consistent between wrapper generation and bwrap mounts.

**Important:** wrapper scripts must exec `sandboxWrapBinaryPath` (not `$PATH`) so:
- PATH injection can't bypass wrappers
- `os.Executable()` points into the runtime directory so `../real/<cmd>` works

## Files to Modify
- cmd/agent-sandbox/bwrap.go - add AddWrapperMounts function
- cmd/agent-sandbox/bwrap_test.go - tests

## Key Invariants
- Real binaries mounted read-only
- Wrapper scripts mounted read-only over original paths (no tampering)
- Convention for finding real binary is consistent
- runtimeBase is unique per sandbox instance (randomized) to prevent conflicts

## Acceptance Criteria

**Unit tests (argument generation in bwrap_test.go):**
1. Real binaries mounted at /run/<random>/agent-sandbox/binaries/real/<name>
2. agent-sandbox mounted at /run/<random>/agent-sandbox/binaries/wrap-binary
3. Wrapper scripts mounted read-only over all original binary paths
4. Path convention consistent with wrap-binary lookup
5. Tests verify mount arguments generated correctly

**E2E tests (deferred to d5g38j8):**
- Wrapped commands actually invoke wrapper scripts
- Blocked commands actually fail
- @git preset rules actually enforced
