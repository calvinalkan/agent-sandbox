#!/usr/bin/env bash
set -euo pipefail

# Sandbox wrapper for coding agents using bwrap for filesystem protection
# Usage: agent-sandbox <agent> [args...]
#
# Supported agents: claude, pi, opencode, codex
#
# How the sandbox works:
#
#   Mount order (later mounts overlay earlier ones):
#   1. --ro-bind / /           Everything read-only as base
#   2. --bind $HOME $HOME      Home directory writable (allows creating new files)
#   3. --ro-bind $HOME/<item>  Each existing file/dir in home read-only (except WRITABLE_PATHS)
#   4. --bind-try <paths>      Specific paths made writable (agent configs, $PWD, etc.)
#
#   This allows agents to create temp files (e.g. .claude.json.tmp.xxx for atomic writes)
#   while protecting existing home directory content from modification.

show_help() {
  cat <<HELP
Usage: agent-sandbox <command> [args...]

Commands:
  check [-q] - exit 0 if inside sandbox, exit 1 if not (-q for quiet)

Agents (with special flags):
  claude    - runs with --permission-mode acceptEdits
  pi        - runs as-is
  opencode  - runs as-is (see note below)
  codex     - runs with --sandbox danger-full-access

Any other command runs as-is in the sandbox.

Examples:
  agent-sandbox claude -p "refactor this function"
  agent-sandbox pi "explain this code"
  agent-sandbox bun install
  agent-sandbox ls -la /

The sandbox provides filesystem protection:
  ✓ Write access: current directory, /tmp, agent's own config
  ✗ Read-only: everything else
  ✓ Network: full access (localhost, internet)
  ✓ Docker: available

OpenCode note:
  Since the sandbox handles filesystem protection, consider adding this
  to your ~/.config/opencode/config.json to skip redundant prompts:

    "permission": {
      "external_directory": "allow"
    }
HELP
}

if [[ $# -eq 0 ]] || [[ "${1:-}" == "-h" ]] || [[ "${1:-}" == "--help" ]]; then
  show_help
  exit 0
fi

# Check if running inside sandbox (for use in hooks/scripts)
if [[ "${1:-}" == "check" ]]; then
  quiet=false
  [[ "${2:-}" == "-q" ]] && quiet=true
  if [[ -e /tmp/.agent-sandbox/marker ]]; then
    $quiet || echo "inside sandbox"
    exit 0
  else
    $quiet || echo "outside sandbox"
    exit 1
  fi
fi

# Get the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

# Ensure sandbox bin scripts are executable
chmod -R +x "$SCRIPT_DIR/bin" 2>/dev/null || true

if [[ "${1:-}" == "--print" ]]; then
  PRINT_ONLY=true
  shift
  AGENT="${1:-}"
  [[ -n "$AGENT" ]] && shift
else
  PRINT_ONLY=false
  if [[ $# -eq 0 ]]; then
    echo "Error: No agent specified" >&2
    echo "Usage: agent-sandbox <agent> [args...]" >&2
    exit 1
  fi
  AGENT="$1"
  shift
fi

# Prevent running in home directory
if [[ "$PWD" == "$HOME" ]]; then
  echo "Error: Cannot run agent-sandbox in home directory" >&2
  exit 1
fi

# Determine agent command
AGENT_CMD=()
case "$AGENT" in
  claude)
    AGENT_CMD=(claude --permission-mode acceptEdits)
    ;;
  pi)
    AGENT_CMD=(pi)
    ;;
  opencode)
    AGENT_CMD=(opencode)
    ;;
  codex)
    AGENT_CMD=(codex --sandbox danger-full-access)
    ;;
  "")
    # No agent (only valid with --print)
    if [[ "$PRINT_ONLY" != true ]]; then
      echo "Error: No command specified" >&2
      exit 1
    fi
    ;;
  *)
    # Run arbitrary command
    AGENT_CMD=("$AGENT")
    ;;
esac

# Resolve docker socket path (may be behind symlink)
DOCKER_SOCK="/var/run/docker.sock"
if [[ -e "$DOCKER_SOCK" ]]; then
  DOCKER_SOCK="$(readlink -f "$DOCKER_SOCK")"
fi

# ============================================================================
# BWRAP MOUNT CONFIGURATION
# ============================================================================
#
# Mount order matters - later mounts overlay earlier ones:
#
#   1. --ro-bind / /             Base: everything read-only
#   2. --bind $HOME $HOME        Home writable (allows new file creation)
#   3. --ro-bind $HOME/<item>    Protect existing home contents (except WRITABLE_PATHS)
#   4. --bind-try <paths>        Make specific paths writable
#
# This design allows agents to:
#   - Create temp files for atomic writes (e.g. .claude.json.tmp.xxx)
#   - Modify their own config files
#   - Work in $PWD
# While protecting:
#   - All system files
#   - Existing home directory content (except explicit exceptions)
#   - Git hooks and config
# ============================================================================

BWRAP_ARGS=(
  --die-with-parent
  --share-net
  --setenv PATH "$SCRIPT_DIR/bin:$PATH"

  # Step 1: Read-only root filesystem
  --ro-bind / /

  # Step 2: Writable home directory (enables new file creation for atomic writes)
  --bind "$HOME" "$HOME"
)

# Paths that should remain writable (excluded from ro-bind protection)
WRITABLE_PATHS=(
  # Agent configs
  "$HOME/.claude"
  "$HOME/.claude.json"
  "$HOME/.pi"
  "$HOME/.opencode"
  "$HOME/.codex"
  # Build tools
  "$HOME/.bun"
  "$HOME/.cache"
  "$HOME/go"
  # Development
  "$HOME/code/experiments"
  "$HOME/code/worktrees"
)

# Convert to associative array for O(1) lookup
declare -A WRITABLE_SET
for p in "${WRITABLE_PATHS[@]}"; do
  WRITABLE_SET["$p"]=1
done

# Step 3: Protect existing home directory contents with ro-bind overlays
# Files/dirs in WRITABLE_PATHS are skipped so they remain writable
while IFS= read -r -d '' item; do
  if [[ -z "${WRITABLE_SET[$item]:-}" ]]; then
    BWRAP_ARGS+=(--ro-bind "$item" "$item")
  fi
done < <(find "$HOME" -maxdepth 1 -mindepth 1 -print0)

# Step 4: Explicit writable paths (some overlap with WRITABLE_PATHS for clarity)
BWRAP_ARGS+=(
  # Current working directory
  --bind "$PWD" "$PWD"

  # Temp directory
  --bind /tmp /tmp

  # Agent config directories and files
  --bind-try "$HOME/.claude" "$HOME/.claude"
  --bind-try "$HOME/.claude.json" "$HOME/.claude.json"
  --bind-try "$HOME/.pi" "$HOME/.pi"
  --bind-try "$HOME/.opencode" "$HOME/.opencode"
  --bind-try "$HOME/.codex" "$HOME/.codex"
  --bind-try "$HOME/.local/share/opencode" "$HOME/.local/share/opencode"
  --bind-try "$HOME/.config/opencode" "$HOME/.config/opencode"

  # Development directories
  --bind-try "$HOME/code/experiments" "$HOME/code/experiments"
  --bind-try "$HOME/code/worktrees" "$HOME/code/worktrees"

  # Wrangler config (for Cloudflare dev servers)
  --bind-try "$HOME/.config/.wrangler" "$HOME/.config/.wrangler"

  # Bun cache (for bun install)
  --bind-try "$HOME/.bun" "$HOME/.bun"

  # Cache directory (uv, pip, etc.)
  --bind-try "$HOME/.cache" "$HOME/.cache"

  # Go modules and binaries
  --bind-try "$HOME/go" "$HOME/go"

  # Docker socket (resolved from symlink)
  --bind-try "$DOCKER_SOCK" "$DOCKER_SOCK"

  # NOTE: 1Password CLI does not work inside bwrap sandboxes.
  # 1Password detects the mount namespace and rejects connections for security.
  # Use `gh` commands outside the sandbox, or pre-authenticate with a token.

  # Required virtual filesystems
  --dev /dev
  --proc /proc

  # Sandbox marker - robust sandbox detection for hooks/scripts.
  # Check with: [[ -e /tmp/.agent-sandbox/marker ]]
  # Cannot be bypassed by unsetting environment variables.
  # The tmpfs contents don't persist; directory may remain but marker won't.
  --tmpfs /tmp/.agent-sandbox
  --ro-bind /dev/null /tmp/.agent-sandbox/marker
)


# ============================================================================
# LINTING/FORMATTING CONFIG PROTECTION
# ============================================================================
# Protect linting and formatting configs from being disabled/weakened by agents.
# These are found recursively in $PWD and mounted read-only.

LINT_CONFIG_PATTERNS=(
  # Go
  ".golangci.yml" ".golangci.yaml" ".golangci.toml" ".golangci.json"
  "golangci.yml" "golangci.yaml"
  # TypeScript/JavaScript (Biome, Oxlint, ESLint, Prettier)
  "biome.json" "biome.jsonc"
  ".oxlintrc.json" "oxlintrc.json" "oxlint.json"
  ".eslintrc" ".eslintrc.js" ".eslintrc.cjs" ".eslintrc.json" ".eslintrc.yml" ".eslintrc.yaml"
  "eslint.config.js" "eslint.config.mjs" "eslint.config.cjs"
  ".prettierrc" ".prettierrc.js" ".prettierrc.cjs" ".prettierrc.json" ".prettierrc.yml" ".prettierrc.yaml" ".prettierrc.toml"
  "prettier.config.js" "prettier.config.cjs" "prettier.config.mjs"
  # TypeScript
  "tsconfig.json" "tsconfig.*.json"
  # Python (Ruff, etc.)
  "pyproject.toml" "ruff.toml" ".ruff.toml"
  ".flake8" ".mypy.ini" "mypy.ini" ".pylintrc" "pylintrc"
  # General
  ".editorconfig"
)

# Build find expression for all patterns
FIND_ARGS=()
for pattern in "${LINT_CONFIG_PATTERNS[@]}"; do
  if [[ ${#FIND_ARGS[@]} -gt 0 ]]; then
    FIND_ARGS+=("-o")
  fi
  FIND_ARGS+=("-name" "$pattern")
done

# Find and protect all matching config files
while IFS= read -r -d '' config_file; do
  BWRAP_ARGS+=(--ro-bind-try "$config_file" "$config_file")
done < <(find "$PWD" -type f \( "${FIND_ARGS[@]}" \) -print0 2>/dev/null)

# Project-specific read-only paths from config file
# Supports both .json and .jsonc (with // and /* */ comments)
CONFIG_FILE=""
for ext in jsonc json; do
  if [[ -f "$PWD/.agent-sandbox.$ext" ]]; then
    CONFIG_FILE="$PWD/.agent-sandbox.$ext"
    break
  fi
done

# Protect both config file variants (even if not used)
BWRAP_ARGS+=(--ro-bind-try "$PWD/.agent-sandbox.json" "$PWD/.agent-sandbox.json")
BWRAP_ARGS+=(--ro-bind-try "$PWD/.agent-sandbox.jsonc" "$PWD/.agent-sandbox.jsonc")

if [[ -n "$CONFIG_FILE" ]]; then
  
  # Strip JSONC comments (// and /* */) before parsing with jq
  # Uses sed to remove single-line // comments and multi-line /* */ comments
  strip_jsonc_comments() {
    sed -e 's|//.*$||' -e ':a' -e 's|/\*.*\*/||' -e 'ta' "$1"
  }
  
  # Mount each path from readonly array
  while IFS= read -r path; do
    [[ -n "$path" ]] && BWRAP_ARGS+=(--ro-bind-try "$PWD/$path" "$PWD/$path")
  done < <(strip_jsonc_comments "$CONFIG_FILE" | jq -r '.readonly[]?' 2>/dev/null)
fi

# Protect .git/hooks and .git/config (only if .git is a directory, not a worktree file)
if [[ -d "$PWD/.git" ]]; then
  BWRAP_ARGS+=(
    --ro-bind-try "$PWD/.git/hooks" "$PWD/.git/hooks"
    --ro-bind-try "$PWD/.git/config" "$PWD/.git/config"
  )
fi

# Handle git worktrees (where .git is a file, not a directory)
if [[ -f "$PWD/.git" ]]; then
  WORKTREE_GITDIR="$(sed -n 's/^gitdir: //p' "$PWD/.git")"
  if [[ -n "$WORKTREE_GITDIR" && -d "$WORKTREE_GITDIR" ]]; then
    # Bind worktree-specific gitdir
    BWRAP_ARGS+=(
      --bind "$WORKTREE_GITDIR" "$WORKTREE_GITDIR"
      --ro-bind-try "$WORKTREE_GITDIR/hooks" "$WORKTREE_GITDIR/hooks"
      --ro-bind-try "$WORKTREE_GITDIR/config" "$WORKTREE_GITDIR/config"
    )
    # Also bind the main .git directory (commondir) where objects/refs live
    if [[ -f "$WORKTREE_GITDIR/commondir" ]]; then
      COMMONDIR="$(cd "$WORKTREE_GITDIR" && cd "$(cat commondir)" && pwd)"
      if [[ -n "$COMMONDIR" && -d "$COMMONDIR" ]]; then
        BWRAP_ARGS+=(
          --bind "$COMMONDIR" "$COMMONDIR"
          --ro-bind-try "$COMMONDIR/hooks" "$COMMONDIR/hooks"
          --ro-bind-try "$COMMONDIR/config" "$COMMONDIR/config"
        )
      fi
    fi
  fi
fi

# Allow creating sibling worktrees if current dir is a git worktree
if [[ -f "$PWD/.git" ]]; then
  WORKTREES_PARENT="$(dirname "$PWD")"
  BWRAP_ARGS+=(--bind "$WORKTREES_PARENT" "$WORKTREES_PARENT")
fi

if [[ "$PRINT_ONLY" == true ]]; then
  echo "bwrap ${BWRAP_ARGS[*]}${AGENT_CMD[*]:+ ${AGENT_CMD[*]}}${*:+ $*}"
else
  exec bwrap "${BWRAP_ARGS[@]}" "${AGENT_CMD[@]}" "$@"
fi
